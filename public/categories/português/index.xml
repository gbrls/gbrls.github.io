<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Português on gbrls - Gabriel Schneider&#39;s website</title>
    <link>https://gbrls.github.io/categories/portugu%C3%AAs/</link>
    <description>Recent content in Português on gbrls - Gabriel Schneider&#39;s website</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 05 Feb 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://gbrls.github.io/categories/portugu%C3%AAs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Solução OBI 2018 Baldes</title>
      <link>https://gbrls.github.io/blog/obi2018-baldes/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gbrls.github.io/blog/obi2018-baldes/</guid>
      <description>Enunciado
Na minha primeira leitura, vi que esta é uma questão clássica de segtree. Um vetor de tamanho \(10^5\) e \(10^5\) queries dentro desse intervalo. Iremos fazer uma segtree para o mínimo num intervalo e outra para o máximo, sendo a resposta da query em um intervalo o max-min. Para simplificar isso, podemos guardar as duas árvores apenas em um vetor de pairs.
Porém após implementar a primeira solução e não funcionar fiz uma segunda leitura e percebi que o max e o min não podem estar no mesmo balde (na mesma posição no vetor).</description>
    </item>
    
    <item>
      <title>Solução OBI 2018 Bolas</title>
      <link>https://gbrls.github.io/blog/obi2018-bolas/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gbrls.github.io/blog/obi2018-bolas/</guid>
      <description>Enunciado.
Como o tamano do vetor é \(8\) e temos sempre \(8\) números para escolher, existem \(8!\) permutações possíveis. Como \(8!\) é pequeno, podemos fazer uma solução de busca completa. Existem de varias soluções possíveis como com next_permutation. Segue uma solução de backtracking:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>Solução OBI 2018 Cinco</title>
      <link>https://gbrls.github.io/blog/obi2018-cinco/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gbrls.github.io/blog/obi2018-cinco/</guid>
      <description>Enunciado
Podemos criar um algoritmo guloso simples, trocar sempre (em ordem):
 O dígito mais significativo que for trocado por um número maior do que ele (na falha do primeiro) O dígito menos significativo que for trocado por um número menor do que ele  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>Solução OBI 2018 Maximin</title>
      <link>https://gbrls.github.io/blog/obi2018-maximin/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gbrls.github.io/blog/obi2018-maximin/</guid>
      <description>Enunciado
Como o tamanho máximo do vetor é \(10^5\) podemos ordená-lo. Fazendo isso podemos ver que o número que estamos procurando está entre dois números vizinhos no vetor ou está em alguma das extremidades.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int main() { int n,r,l; scanf(&amp;#34;%d%d%d&amp;#34;,&amp;amp;n,&amp;amp;r,&amp;amp;l); int arr[n]; for(int i=0;i&amp;lt;n;i++) scanf(&amp;#34;%d&amp;#34;,&amp;amp;arr[i]); sort(arr,arr+n); int dif=0; for(int i=1;i&amp;lt;n;i++) { int mid=(arr[i]+arr[i-1])/2; if(mid&amp;gt;=r&amp;amp;&amp;amp;mid&amp;lt;=l) dif=max(dif,min(abs(mid-arr[i]),abs(mid-arr[i-1]))); } if(l&amp;gt;arr[n-1]) dif=max(dif, l-arr[n-1]); if(r&amp;lt;arr[0]) dif=max(dif,arr[0]-r); printf(&amp;#34;%d\n&amp;#34;,dif); return 0; }   </description>
    </item>
    
    <item>
      <title>Solução OBI 2018 Muro</title>
      <link>https://gbrls.github.io/blog/obi2018-muro/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gbrls.github.io/blog/obi2018-muro/</guid>
      <description>Enunciado
Podemos criar uma função recursiva \(f\):
$$ f(0) = 1 $$
$$ f(n) = f(n-1) + 4f(n-2) + 2f(n-3) \quad \text{para } n &amp;gt; 0 $$
Como existem estados que irão se repetir, podemos usar um vetor para guardar o valor da função já computados.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include &amp;lt;bits/stdc++.</description>
    </item>
    
  </channel>
</rss>