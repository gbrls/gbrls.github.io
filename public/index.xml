<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gbrls - Gabriel Schneider&#39;s website</title>
    <link>https://gbrls.github.io/</link>
    <description>Recent content on gbrls - Gabriel Schneider&#39;s website</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 26 Mar 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://gbrls.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Binary Binary Tree</title>
      <link>https://gbrls.github.io/posts/binbin-tree/</link>
      <pubDate>Tue, 23 Feb 2021 20:22:52 -0300</pubDate>
      
      <guid>https://gbrls.github.io/posts/binbin-tree/</guid>
      <description>The trick I really like tricks with binary numbers. This one I was using to test digital systems.
 So, were does this come from? Is this generated by some slow recursive algorithm?
No!
This complete binary tree is generated by this code:
 if (col &amp;amp; (1 &amp;lt;&amp;lt; line)) != 0 { *pixel = c[line % c.len()]; }  How it works So, how does this work?</description>
    </item>
    
    <item>
      <title>Test2</title>
      <link>https://gbrls.github.io/blog/test2/</link>
      <pubDate>Sun, 21 Feb 2021 11:22:10 -0300</pubDate>
      
      <guid>https://gbrls.github.io/blog/test2/</guid>
      <description>Hey there people, I&amp;rsquo;m bobby brown.
Distribution.</description>
    </item>
    
    <item>
      <title>Hello</title>
      <link>https://gbrls.github.io/blog/hello/</link>
      <pubDate>Thu, 18 Feb 2021 16:09:43 -0300</pubDate>
      
      <guid>https://gbrls.github.io/blog/hello/</guid>
      <description>Hello there people I&amp;rsquo;m bobby brown.
Help.</description>
    </item>
    
    <item>
      <title>myLisp Interpreter 2: Functions and Eval</title>
      <link>https://gbrls.github.io/blog/mk-lisp-2/</link>
      <pubDate>Mon, 20 Apr 2020 19:22:06 -0300</pubDate>
      
      <guid>https://gbrls.github.io/blog/mk-lisp-2/</guid>
      <description>This is the third part of a series of articles that I&amp;rsquo;m writing to document by progress on building a Interpreter for myLisp, a lisp-like language. For the previous post click here.
myLisp symbols From the previous articles myLisp&amp;rsquo;s symbols are just strings, but if we write (CONS (QUOTE A) nil) how does de compiler know which piece of code runs when CONS is called? It doesn&amp;rsquo;t know. So we are going to change the symbol representation from a string to a struct:</description>
    </item>
    
    <item>
      <title>myLisp Interpreter 1: Lexer and Parser</title>
      <link>https://gbrls.github.io/blog/mk-lisp-1/</link>
      <pubDate>Mon, 30 Mar 2020 16:24:43 -0300</pubDate>
      
      <guid>https://gbrls.github.io/blog/mk-lisp-1/</guid>
      <description>This is the second part of a series of articles that I&amp;rsquo;m writing to document by progress on building a Interpreter for myLisp, a lisp-like language. For the previous post click here.
 What is an interpreter? An Interpreter is a program that takes souce code as input and executes it. It is composed of several parts, today we are going to write a lexer and a parser.
The lexer will read a string of characters and output a vector of tokens, with some information attached to them like its type.</description>
    </item>
    
    <item>
      <title>myLisp Interpreter 0: What is Lisp?</title>
      <link>https://gbrls.github.io/blog/mk-lisp-0/</link>
      <pubDate>Sun, 29 Mar 2020 02:56:40 -0300</pubDate>
      
      <guid>https://gbrls.github.io/blog/mk-lisp-0/</guid>
      <description>This is the first part of a series of articles that I&amp;rsquo;ll be writing to document my progress on building a interpreter for a Lisp-like language.
I&amp;rsquo;ve been interested in learning different programming languages for a while now, I&amp;rsquo;ve read the first chapters of Haskell and Lisp books recently and the one that hooked me on was Land of lisp. Lisp&amp;rsquo;s simplicity really struck me: from very simple building blocks you can create anything in such an elegant and simple way.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://gbrls.github.io/about/</link>
      <pubDate>Thu, 26 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gbrls.github.io/about/</guid>
      <description>Hi! My name is Gabriel Schneider.
I like Programming Languages, Compilers, Gamedev, Competitive programming and many other things.
My github.</description>
    </item>
    
    <item>
      <title>Solução OBI 2018 Baldes</title>
      <link>https://gbrls.github.io/blog/obi2018-baldes/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gbrls.github.io/blog/obi2018-baldes/</guid>
      <description>Enunciado
Na minha primeira leitura, vi que esta é uma questão clássica de segtree. Um vetor de tamanho \(10^5\) e \(10^5\) queries dentro desse intervalo. Iremos fazer uma segtree para o mínimo num intervalo e outra para o máximo, sendo a resposta da query em um intervalo o max-min. Para simplificar isso, podemos guardar as duas árvores apenas em um vetor de pairs.
Porém após implementar a primeira solução e não funcionar fiz uma segunda leitura e percebi que o max e o min não podem estar no mesmo balde (na mesma posição no vetor).</description>
    </item>
    
    <item>
      <title>Solução OBI 2018 Bolas</title>
      <link>https://gbrls.github.io/blog/obi2018-bolas/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gbrls.github.io/blog/obi2018-bolas/</guid>
      <description>Enunciado.
Como o tamano do vetor é \(8\) e temos sempre \(8\) números para escolher, existem \(8!\) permutações possíveis. Como \(8!\) é pequeno, podemos fazer uma solução de busca completa. Existem de varias soluções possíveis como com next_permutation. Segue uma solução de backtracking:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>Solução OBI 2018 Cinco</title>
      <link>https://gbrls.github.io/blog/obi2018-cinco/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gbrls.github.io/blog/obi2018-cinco/</guid>
      <description>Enunciado
Podemos criar um algoritmo guloso simples, trocar sempre (em ordem):
 O dígito mais significativo que for trocado por um número maior do que ele (na falha do primeiro) O dígito menos significativo que for trocado por um número menor do que ele  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>Solução OBI 2018 Maximin</title>
      <link>https://gbrls.github.io/blog/obi2018-maximin/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gbrls.github.io/blog/obi2018-maximin/</guid>
      <description>Enunciado
Como o tamanho máximo do vetor é \(10^5\) podemos ordená-lo. Fazendo isso podemos ver que o número que estamos procurando está entre dois números vizinhos no vetor ou está em alguma das extremidades.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int main() { int n,r,l; scanf(&amp;#34;%d%d%d&amp;#34;,&amp;amp;n,&amp;amp;r,&amp;amp;l); int arr[n]; for(int i=0;i&amp;lt;n;i++) scanf(&amp;#34;%d&amp;#34;,&amp;amp;arr[i]); sort(arr,arr+n); int dif=0; for(int i=1;i&amp;lt;n;i++) { int mid=(arr[i]+arr[i-1])/2; if(mid&amp;gt;=r&amp;amp;&amp;amp;mid&amp;lt;=l) dif=max(dif,min(abs(mid-arr[i]),abs(mid-arr[i-1]))); } if(l&amp;gt;arr[n-1]) dif=max(dif, l-arr[n-1]); if(r&amp;lt;arr[0]) dif=max(dif,arr[0]-r); printf(&amp;#34;%d\n&amp;#34;,dif); return 0; }   </description>
    </item>
    
    <item>
      <title>Solução OBI 2018 Muro</title>
      <link>https://gbrls.github.io/blog/obi2018-muro/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gbrls.github.io/blog/obi2018-muro/</guid>
      <description>Enunciado
Podemos criar uma função recursiva \(f\):
$$ f(0) = 1 $$
$$ f(n) = f(n-1) + 4f(n-2) + 2f(n-3) \quad \text{para } n &amp;gt; 0 $$
Como existem estados que irão se repetir, podemos usar um vetor para guardar o valor da função já computados.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include &amp;lt;bits/stdc++.</description>
    </item>
    
  </channel>
</rss>