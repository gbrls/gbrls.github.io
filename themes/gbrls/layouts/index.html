{{ define "title" }}
{{ .Site.Title }}
{{ end }}

{{ define "main" }}
<h1>{{ .Title }}</h1>

<div class="column" style="z-index: 5;">
    <div class="left">
        <div class="index-div">
            {{ .Content }}
        </div>
    </div>
    <div class="right">
     <div class="slidecontainer">
          <input type="range" min="-100" max="100" value="0" class="slider" id="range0">
          <p id="pr0"></p>
          <input type="range" min="-100" max="100" value="0" class="slider" id="range1">
          <p id="pr1"></p>
          <button onclick="getData(s1, s0)">get data</button>
          <button onclick="query()">query</button>
          <p id="geodata"></p>
     </div>
        {{partial "list.html" .}}
    </div>
</div>
<script src="three.min.js"></script>
<script>
var camera, scene, renderer;
var geometry, material, mesh, material2;
var mouse;
var x, y;
var px, py;
var s0, s1;
var lat = 0.0;
var long = 0.0;


init();
animate();

const myPics = document.getElementById('faq');

var htmls0 = document.getElementById("range0");
var htmls1 = document.getElementById("range1");

var pr0 = document.getElementById("pr0");
var pr1 = document.getElementById("pr1");
var gdata = document.getElementById("geodata");

function toLat(x) {
    return ((x / Math.PI) * 2. - 1.) * 90.;
}

function toLong(x) {
    return ((x / Math.PI) * 180.);
}

htmls0.oninput = function() {
    s0 = this.value / 100.0;
    // we want it from 0 to PI
    s0 = (s0 / 2. + 0.5) * Math.PI;

    lat = ((s0 / Math.PI) * 2. - 1.) * 90.;

    pr0.innerHTML = "ϕ = " + (s0 / Math.PI).toFixed(2) + "π, lat = " + lat.toFixed(2);
    console.log(s0);
    //gdata.innerHTML = r.lat + ":" + r.lon;
}

htmls1.oninput = function() {
    s1 = this.value / 100.0;
    s1 = (s1 / 2.) * Math.PI * 2.0;
    
    long = ((s1 / Math.PI) * 180.);

    pr1.innerHTML = "θ = " + (s1 / Math.PI).toFixed(2) + "π, lon = " + long.toFixed(2);
    console.log(s1);
}


document.addEventListener('mousedown', e => {
    x = e.offsetX;
    y = e.offsetY;
});

document.addEventListener('mousemove', e => {

    px = x;
    py = y;

    x = e.offsetX;
    y = e.offsetY;
});

function getPoints() {
    points = [];

    for (let i = 0; i < 80; i++) {
        let x = (i/5.0);
        points.push(new THREE.Vector3(Math.random() - 0.5,
         Math.random() - 0.5,
          Math.random() - 0.5
          ));
    }


    return points;
}

function init() {

    s0 = 0.05;
    s1 = 0.05;
    camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
    camera.position.z = 5;


    scene = new THREE.Scene();

    const _vs = `
uniform float u_time;
uniform float input1;
uniform int npoints;
uniform vec3 points[1280];

out vec3 UV;
void main() {
    vec3 npos = position; //+ vec3(0, 0, 0.8*sin(u_time/5.));
    gl_Position = projectionMatrix * modelViewMatrix * vec4(npos, 1.0);
    //@TODO: use spherical coordinates.
    UV = position / length(position); // normalizing the coordinates
}
`;

    const _fs = `
uniform float u_time;
uniform float input1;
uniform int npoints;
uniform vec3 points[1280];
in vec3 UV;
float pi = 3.14;
float PI = 3.14;

float atan2(float y, float x) {
    bool s = (abs(x) > abs(y));
    return mix(PI/2.0 - atan(x,y), atan(y,x), s);
}

void main() {
    float phi = acos(UV.y / length(UV));
    float theta = atan(UV.z, UV.x);
    vec3 oceanC = vec3(0.1, 0.3, 0.8);
    vec3 groundC = vec3(0.5, 0.5, 0.3);

    vec4 myCol;

    vec2 point = vec2(input1, u_time);

    float d = distance(point, vec2(theta, phi));
    float ground = 0.0;

    for (int i = 0; i < 1000; i++) {
        vec2 p = points[i].xy;
        float cd = distance(p, vec2(theta, phi));
        if (cd < d) {
            d = cd;
            ground = points[i].z;
        }
    }

    if (d > 0.02) {
        myCol = vec4(vec3(0.0), 1.0);
    } else {
        if(ground > 0.5) {
            myCol = vec4(oceanC, 1.0);
        } else {
            myCol = vec4(groundC, 1.0);
        }
        myCol = vec4(vec3(ground + 0.5), 1.0);
    }
    
    gl_FragColor = mix(vec4(UV.x, UV.y, UV.z, 1.0), myCol, 0.8);
    //gl_FragColor = vec4(UV.x/2.0 + 0.5, UV.y/2.0 + 0.5, UV.z/2.0 + 0.5, 1.0);
}
`;

    material2 = new THREE.ShaderMaterial({
        uniforms: {
            "u_time"  : {value: 8.1},
            "input1"  : {value: 0.0},
            "npoints" : {value: 0},
            "points"  : {value: new Array(1280).fill(new THREE.Vector3(0., 0., 0.))}, },
        vertexShader: _vs,
        fragmentShader: _fs,
    });

    //geometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
    //material = new THREE.MeshNormalMaterial();
    material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 5.0 });
    points = getPoints();

    //geometry = new THREE.BufferGeometry().setFromPoints(points);
    geometry = new THREE.SphereGeometry(1, 32, 16);

    mesh = new THREE.Mesh( geometry, material2);
    //mesh = new THREE.LineSegments(geometry, material2);
    scene.add( mesh );

    renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
    renderer.setClearColor(0xff0000, 0.0); // the default
    renderer.setSize( window.innerWidth, window.innerHeight );

    document.body.appendChild( renderer.domElement );


}

function animate() {

    requestAnimationFrame( animate );

    material2.uniforms.u_time.value = s0;
    material2.uniforms.input1.value = s1;
    //mesh.rotation.y += 0.01; 
    mesh.rotation.y = 4;
    //mesh.rotation.x = 1.51;

    renderer.render( scene, camera );

}

String.prototype.format = function() {
  a = this;
  for (k in arguments) {
    a = a.replace("{" + k + "}", arguments[k])
  }
  return a
}

function getData(LA, LO) {
    var requestOptions = {
            method: 'GET',
        };


    console.log("LA" + toLat(LA) + ": " + LA);
    console.log("LO" + toLong(LO) + ": " + LO);

    material2.uniforms.npoints.value += 1;
    material2.uniforms.npoints.value %= 1000;
    material2.uniforms.points.value[material2.uniforms.npoints.value] = new THREE.Vector3(LA, LO, 0.),
    console.log(material2.uniforms.npoints.value);

    //let api_arg = "https://api.geoapify.com/v1/geocode/reverse?lat=51.21709661403662&lon=6.7782883744862374&apiKey=38d0b06048b14039b7e4abba032b29b2";
    let api_arg = "https://api.geoapify.com/v1/geocode/reverse?lat={0}&lon={1}&apiKey=38d0b06048b14039b7e4abba032b29b2".format(toLat(LO), toLong(LA));
    console.log(api_arg);
    fetch(api_arg, requestOptions)
        .then(response => response.json())
        .then(result => updateWithResult(result))
        .catch(error => console.log('error', error));

    console.log("Resultado aí ó");
    console.log(lat);
    //console.log(res);
}

function updateWithResult(result) {
    let r = result.features[0].properties;
    console.log("Updating");
    console.log(r);
    if ('country' in r) {
        console.log('Land!');
        material2.uniforms.points.value[material2.uniforms.npoints.value].z = 1.0;
    } else {
        material2.uniforms.points.value[material2.uniforms.npoints.value].z = 0.0;
    }
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function query() {
    for (let i = 0; i < 5; i += 0.3) {
        for (let j = 0; j < 8; j += 0.3) {
            //setTimeout(() => { getData(s1 + (i / 10.), s0); }, 2000);
            await sleep(1200);
            getData(s1 + (i / 10.), s0 + (-j / 10.));
        }
    }
}

</script>
{{ end }}
